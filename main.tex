%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf]{acmart}

\usepackage{code}
\hypersetup{draft}
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2021}
\acmYear{2021}
\acmDOI{10.1145/1122445.1122456}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Woodstock '18]{Woodstock '18: ACM Symposium on Neural
  Gaze Detection}{June 03--05, 2018}{Woodstock, NY}
\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
  June 03--05, 2018, Woodstock, NY}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{DeepState: Unit Testing Unbound}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Alex Groce}
\affiliation{\institution{Northern Arizona University}\country{United States}}
\author{Peter Goodman}
\author{Gustavo Grieco}
\affiliation{\institution{Trail of Bits}\country{United States}}
\author{Alan Cao}
\affiliation{\institution{New York University}\country{United States}}



%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Groce, Goodman, Grieco, and Cao}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Almost every software developer knows how to write a unit test; very few software developers know how to use fuzzing or symboilic execution tools.  DeepState provides a way to write parameterized/generalized unit tests by adding data generation and nondeterministic choice constructs to a Google Test-like API.  DeepState can then use modern fuzzers such as afl or libFuzzer, or the Manticore symbolic execution tool, to construct concrete tests.  DeepState makes it easy to apply mulitple fuzzers, including in a cooperative ensemble, to a testing problem, and to use fuzzers for full-fledged property-based testing with complex input validity and correctness constraints.  DeepState also adds swarm testing and smart test reduction and normalization capabilities to fuzzers without the need to modify the back-end tool.
\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011074.10011099.10011102.10011103</concept_id>
<concept_desc>Software and its engineering~Software testing and debugging</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Dynamic analysis}
\ccsdesc[500]{Software and its engineering~Software testing and debugging}

\keywords{parameterized unit tests, fuzzing, symbolic execution, test reduction}


\maketitle

\section{Introduction}

Automated test generation using sophisticated methods, including fuzzers and symbolic execution, has the potential to greatly improve the reliability, safety, and security of software systems.  Unfortunately, few real-world developers have any experience using such tools, and the widely differing ways test harnesses must be written \cite{WODACommon} and tools must be run limit knowledge transfer from one tool to another.  DeepState \cite{goodman2018deepstate} provides a single front-end that allows a developer to \emph{write a single parameterized unit test} \cite{ParamUnit}  and then use a variety of fuzzers and/or symbolic execution tools to generate test cases in a single, shared, binary format.  DeepState has been used in internal security audits at Trail of Bits, and to detect bugs in real-world code (\url{https://github.com/Blosc/c-blosc2/issues/95}, \url{https://github.com/laurynas-biveinis/unodb}, \url{https://github.com/RoaringBitmap/CRoaring}); DeepState is being used in various non-public testing efforts, as well.

\section{A Simple Example}

\begin{figure}
{\scriptsize
\begin{code}
\#include <deepstate/DeepState.hpp>
using namespace deepstate;

\#include  "runlen.h"

// This can be much higher for fuzzing, but should be small for
// symbolic execution to scale
\#define MAX\_STR\_LEN 6

TEST(Runlength, EncodeDecode) \{
  char* original = DeepState\_CStrUpToLen(MAX\_STR\_LEN,
                                         "abcdef0123456789");
  char* encoded = encode(original);
  ASSERT\_LE(strlen(encoded), strlen(original)*2) <<
   "Encoding is > length*2!";
  char* roundtrip = decode(encoded);
  ASSERT\_EQ(strncmp(roundtrip, original, MAX\_STR\_LEN), 0) <<
    "ORIGINAL: '" << original << "', ENCODED: '" << encoded <<
    "', ROUNDTRIP: '" << roundtrip << "'";
\}
\end{code}
}
  \caption{A Simple DeepState Test Harness}
  \label{fig:example}
  \end{figure}

  As Figure~\ref{fig:example}, taken from an example in the DeepState repository, but omitting the actual (buggy) code for a runlength encoding shows, DeepState test harnesses look very much like the very widely used GoogleTest (\url{https://github.com/google/googletest}) framework.  The great difference is the use of DeepState API calls to replace fixed, concrete values with tool-generated values, and the use of more general, property-based-testing style, specifications to account for the variability of test data.  Here, the ``work'' is done by {\tt DeepState\_CStrUpToLen}, which takes a maximum string length and (optionally) an alphabet to use, and generates (and manages memory for) string inputs.  DeepState similarly provides APIs for all common C/C++ base types, including generation of values in ranges (e.g., {\tt DeepState\_IntInRange}, {\tt DeepState\_DoubleInRange}, etc.).
Once such a harness is written, test generation is easy.  Simply compiling the test and linking with the DeepState binary, via a command such as {\tt clang++ -o runlen Runlen.cpp -ldeepstate} allows a user to use symbolic execution via Manticore \cite{mossberg2019manticore}, the Eclipser fuzzer \cite{choi:icse:2019}, afl in QEMU mode, or DeepState's built-in dumb (but very fast) fuzzer:

  {\scriptsize
\begin{code}
> deepstate-manticore ./runlen --output\_test\_dir manticore\_symex
...
> deepstate-eclipser ./runlen --output\_test\_dir eclipser\_fuzzing
...
> ./runlen --fuzz --output\_test\_dir bruteforce\_fuzzing
...
\end{code}
}

Fuzzing with afl or another fuzzer requiring compile-time instrumentation is only slightly more difficult:

{\scriptsize
\begin{code}
> deepstate-afl --compile\_test ./Runlen.cpp --out\_test\_name runlen
...
> deepstate-afl ./runlen.afl --fuzzer\_out --output\_test\_dir afl\_fuzzing
\end{code}
}

\begin{figure}
{\scriptsize
\begin{code}
    OneOf(
	  [\&] \{MakeNewPath(path);
            r = tfs\_mkdir(sb, path);
            LOG(TRACE) << "tfs\_mkdir(sb, \"" << path << "\") = " << r;
	  \},
	  [\&] \{MakeNewPath(path);
            r = tfs\_rmdir(sb, path);
            LOG(TRACE) << "tfs\_rmdir(sb, \"" << path << "\") = " << r;
	  \},
	  [\&] \{r = tfs\_ls(sb);
            LOG(TRACE) << "tfs\_ls(sb) = " << r;
	  \},
   ...
\end{code}
}
  \caption{OneOf in Action}
  \label{fig:oneof}
  \end{figure}


A major feature of the DeepState API not shown in the first example is the {\tt OneOf} construct, which takes as parameter a vector, array, string, or an arbitrary number of C++ lambdas.  In the first three cases, it returns a nondetermnistic element of the sequence; for lambdas, it selects and executes one of the code choices.  This makes the basic ``choose and run one option'' structure of API call sequence testing trivial to implement.  Figure~\ref{fig:oneof} shows use of OneOf in a harness for testing a file system developed at U. Toronto \cite{testfs}.  For an extended example of {\tt OneOf} see the TestFS harness (\url{https://github.com/agroce/testfs}) or a DeepState harness for differential testing of Google's leveldb and Facebook's rocksdb \url{https://github.com/agroce/testleveldb}.  Behind the scenes, the alphabet parameter to {\tt DeepState\_CstrUpToLen} also operates as a {\tt OneOf}, which means that swarm testing (see below) and other {\tt OneOf} semantics automatically are used when producing restricted-alphabet strings.
  
\section{Supported Fuzzers and Back Ends}

DeepState includes full-featured front-ends for libFuzzer, afl \cite{aflfuzz}, libFuzzer, Eclipser \cite{choi:icse:2019}, Angora \cite{chen2018angora}, and Honggfuzz (\url{https://github.com/google/honggfuzz}), as well as a built-in, extremely fast dumb fuzzer for quick discovery of some bugs.  It also, using the same interface, allows users to generate tests via symbolic execution using Manticore \cite{mossberg2019manticore}, as noted above.

In addition, DeepState can interface with any fuzzer that allows fuzzing via either file inputs or stdin, which means, in practice, the majority of fuzzers that are being developed now.  If a fuzzer is similar in interface to a fully-supported fuzzer (e.g., afl, the basis for many fuzzer variants), then writing and submitting a first-class interface is usually trivial.

\section{More Than A Front-End}

\subsection{Swarm Testing}

Swarm testing \cite{ISSTA12,groce2013help} is a low-cost, high-impact approach to improving test generation, widely used in compiler testing \cite{le2014compiler,dewey2015fuzzing} and as a foundation for the test approach for FoundationDB, the back-end database for Apple and Snowflake cloud services \cite{zhou2021foundationdb}.  Heretofore, no fuzzers to our knowledge have included support for swarm testing, which operates by constructing tests that universally omit some options in repeated choices (e.g. among API calls or options).  The swarm testing concept aligns perfectly with DeepState's {\tt OneOf} construct, and DeepState allows the use of swarm testing with any fuzzer, simply by compiling the DeepState harness with the swarm option enabled.  The impact can be extremely large.  For example, finding the simple stack overflow in \url{https://github.com/agroce/deepstate-stack} requires less than one second using afl, libFuzzer, or even DeepState's built-in dumb fuzzer, using swarm testing, but an average of over an hour to detect with afl when not using swarm testing, and (we estimate) trillions of years with the brute-force fuzzer not using swarm testing.  A core goal of DeepState is to enable the exploration and use of test generation strategies that do not need to be implemented in individual fuzzers, but operate on a more semantic level.

\subsection{State-of-the-Art Test Reduction}

\subsection{Ensemble Fuzzing}

Ensemble fuzzing \cite{chen2019enfuzz} extends the idea of ensemble learning, where multiple machine learning methods are applied to a problem, given the unpredictable diversity of performance of methods, to the fuzzing problem.  DeepState supports automatic cooperative fuzzing, using tests generated by one fuzzer to seed another.  The best known other implementation of ensemble fuzzing (\url{http://wingtecher.com/Enfuzz} requires uploading source code to a web site, supports a more limited set of fuzzers than DeepState (lacking Eclipser and Angora), and requires use of the very limited API of a standard libFuzzer char buffer interface to fuzzing.  DeepState in contrast lets users write parameterized unit tests as usual, but then use any fuzzers DeepState provides for cooperative fuzzing.

\subsubsection{Experimental Evaluation}

\begin{table}
\centering
\begin{tabular}{l|r|r}
 & Runlen & TweetNaCl Bug \\
  Fuzzer & Mean Crash Time & Mean Crash Time \\
  \hline
  {\bf Ensembler} & 3.29s & 4m13s \\
  afl & 7.01s & 3m 39s \\
  libFuzzer & 4.05s & 4m 19s \\
  Angora & 7.06s & 10m 47s \\
  Eclipser & 2.74s & 12m 45s \\
\end{tabular}
\caption{Ensemble fuzzing experiments}
\label{tab:ensemble}
\end{table}

Table~\ref{tab:ensemble} shows, for simple examples, some of the benefits of the ensembler.  The first example, Runlen, is the DeepState example included in the distribution and discussed above.  The second is a real-world bignum vulnerability \url{http://seb.dbzteam.org/blog/2014/04/28/tweetnacl_arithmetic_bug.html\#fn:2}.  In addition to the benefits described in the academic literature, where cooperative fuzzing can find bugs no single fuzzer finds well, an ensemble also mediates fuzzer variability, often (as here) ensuring that any faults are found about as quickly as by the \emph{best} of the individual fuzzers.  Note that Eclipser and Angora work well on the simple buggy run length encoder, but struggle with the more complex example.  Is it a good idea to use Eclipser?  Ensemble fuzzing lets a developer who just wants to find bugs avoid thinking about such problems.

\section{Related Work}

DeepState lies at the intersection of practical work on unit testing frameworks (e.g., JUnit or GoogleTest) and test generation research.  In particular, DeepState inherits from two approaches.  Parameterized unit testing \cite{ParamUnit,UnitMeister} argues that ``closed'' unit tests should be opened by providing a way to specify that some values are to be filled in by a tool.  DeepState extends this idea to allow the generation to be done via either fuzzers or symbolic execution tools, or simply by stored test cases.  Second, DeepState is fundamentally a property-based testing \cite{ClaessenH00,Hypothesis}  tool, and parameterized unit test specifications work much like those in any property-based testing tool for an imperative language.  The idea of a universal tool for automated test generation where the generation technology is a detail, not the focus, arises from efforts to test the Curiosity Mars Rover code at NASA/JPL \cite{AMAI,WODACommon,WODA08}.

\section{Conclusions}

DeepState is available as an open source tool on GitHub \url{https://github.com/trailofbits/deepstate}, and includes support for automatically building a docker environment with all supported fuzzers and symbolic execution tools installed.  The version used in the demonstration and in preparing this paper can be downloaded via {\tt docker pull agroce/deepstate\_demo:latest}.  With DeepState, every developer who knows how to write unit tests in C and C++ can take advantage of the power of modern fuzzers and symbolic execution tools.  Moreover, we believe that DeepState may be a useful basis for experiments comparing various fuzzers, as it provides a common semantics for tests, without forcing researchers to develop equivalent test harnesses.

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}